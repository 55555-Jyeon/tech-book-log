## 👩🏻‍💻 additional Information

### 1. 동등 비교

    ① 리액트의 가상 돔과 실제 돔의 비교
    ② 리액트 컴포넌트가 렌더링할지를 판단하는 방법
    ③ 변수나 함수의 메모이제이션

위 세 가지를 포함한 리액트의 모든 작업은 자바스크립트의 동등 비교를 기반으로 합니다.

리액트에서 자바스크립트의 동등 비교를 어떻게 활용하는지 확인하기 위해서는 데이터 타입에 대해서 먼저 짚고 넘어가는 것이 이해를 돕는데 수월할 것 같습니다.

<br />
<br />

### 데이터 타입

자바스크립트의 모든 값은 데이터 타입을 갖고 있으며 데이터 타입은 크게 원시 타입과 객체 타입으로 나눌 수 있습니다.

원시 타입은 객체가 아닌 다른 모든 타입을 말하며 <br />
자바스크립트에는 총 7개(boolean, null, undefined, number, string, symbol, bigint)가 이에 해당합니다.

객체 타입(참조 타입)은 원시 타입을 제외한 모든 것(배열, 함수, 정규식 클래스 등 대부분)이 여기에 해당됩니다.

<br />

### 데이터 타입과 동등 비교

데이터 타입 간의 가장 큰 차이는 값을 저장하는 방식이며 이는 동등 비교를 할 때의 차이가 발생하는 원인이기도 합니다.

원시 타입은 불변 형태의 값으로 저장되며 해당 값은 변수가 할당되는 시점에 메모리 영역에 저장됩니다. <br />
값을 복사할 때에도 값 자체를 복사해서 전달합니다.

반면에 객체 타입은 프로퍼티가 변경될 수 있기 때문에(추가, 삭제, 수정) 변경 가능한 형태로 저장됩니다. <br />
값을 복사할 때 값 자체가 아닌 참조를 전달합니다.<br />
따라서 값은 같을지언정 참조하는 곳이 다르기 때문에 객체를 동등 비교하게 되면 false를 반환하게 됩니다.

따라서 자바스크립트에서 객체 간의 비교가 발생하면, 결과의 대부분이 true가 아닐 수 있음을 인지하고 있어야 합니다.

<br />
<br />

### Object.is

`Object.is`는 일치 비교(===)의 한계를 극복하기 위해 ES6에서 새롭게 도입된 비교 문법입니다.

    ① NaN === NaN은 false이지만, Object.is(NaN, NaN)은 true를 반환합니다.
    ② 0 === -0은 true지만, Object.is(0, -0)은 false입니다.

하지만 자바스크립트의 특징 때문에 객체를 비교할 때에는 `Object.is`도 일치 비교와 큰 차이 없이 동작하게 됩니다.

<br />
<br />

### 리액트의 동등비교, shallowEqual

리액트에서는 `Object.is`를 기반으로 동등 비교를 하는 `shallowEqual` 함수를 만들어 사용합니다.

```js
    리액트에서의 비교 요약

    ① `Object.is`로 먼저 비교를 진행
    ② `Object.is`에서 수행하지 못하는 비교(객체 간 얕은 비교)를 한 번 더 수행
```

<h5> $\color{#2699E6} Q. 왜 리액트에서는 얕은 비교까지만 구현했을까?</h5>

<h5> $\color{#FFA832} A. 기본적으로 리액트는 props에서 꺼내온 값을 기준으로 렌더링을 수행하기 때문에 일반적으로 얕은 비교로 충분하기 때문입니다. </h5>

리액트가 얕은 비교(shallow comparison)까지만 구현된 이유는 주로 성능 최적화와 예측 가능성 때문입니다. 깊은 비교(deep comparison)는 더 정확하게 객체의 모든 내부 구조를 비교할 수 있지만, 리액트에서 꼭 필요한 경우가 아닌 한, 이러한 방식은 비용이 크기 때문에 기본적으로 지원되지 않습니다.

하지만 얕은 비교만 진행하기 때문에 props가 깊어질 경우 예상치 못하게 작동할 수 있음에 유의해야 합니다.

<br />

이는 향후 함수 컴포넌트에서 사용되는 훅의 의존성 배열의 비교, 렌더링 방지를 넘어선 useMemo와 useCallback의 필요성, 렌더링 최적화를 위해 꼭 필요한 React.memo를 올바르게 작동시키 위해 고려해야 하는 점들을 이해하는데 도움이 됩니다.

<br />
<br />

#### shallowEqual의 작동 방식

shallowEqual 함수는 두 개의 객체를 받아 각각의 키와 값이 같은지를 비교합니다.

구조적으로는 다음과 같은 방식으로 작동합니다:

    ① 객체의 참조가 같은지를 먼저 확인합니다. 같다면 바로 true를 반환합니다.
    ② 키의 개수를 먼저 비교하여 다르면 바로 false를 반환합니다.
    ③ 각 프로퍼티의 값을 비교합니다.
        이때도 값 자체만을 비교하며, 그 값이 객체 타입일 경우에는 참조만 비교합니다.

<br />

리액트에서 **React.memo**와 같은 최적화에서 기본적으로 shallowEqual이 활용됩니다. <br />
이를 통해 객체나 배열처럼 자주 참조가 변경되지 않는 데이터에 대해 얕은 비교를 수행하고, 필요 없는 재렌더링을 피하게 됩니다.

```js
// example
// 이 경우, props.name이 얕게 비교되며, props가 변경되지 않으면 다시 렌더링되지 않습니다.

import React from "react";
import shallowEqual from "shallowequal";

const MyComponent = React.memo((props) => {
  return <div>{props.name}</div>;
}, shallowEqual);
```
