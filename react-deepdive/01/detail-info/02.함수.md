## 👩🏻‍💻 additional Information

### 2. 함수

###### 용어 정리 모음

> 📖 함수 <br />
> 작업 과정을 표현하고, 이를 하나의 블록으로 감싸 실행 단위로 만들어 놓은 것을 의미

> 📖 표현식 <br />
> 무언가 값을 산출하는 구문을 의미

> 📖 일급 객체 <br />
> 다른 객체들에게 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미 <br />
> 함수는 일급객체 → 다른 함수의 매개변수, 반환값이 될 수도 있고 할당도 가능

<br />
<br />

### 함수를 정의하는 4가지 방법

#### ① 함수 선언문

함수 선언문은 가장 일반적으로 함수를 선언하는 방식입니다.<br />
함수 선언문은 표현식이 아닌 일반 문(statement)으로 분류됩니다.

```js
function add(a, b) {
  return a + b;
}
```

<br />

#### ② 함수 표현식

함수 선언문은 말 그대로 '선언'이고 어떠한 값도 표현하지 않으므로 표현식과는 다르게 변수에 할당할 수 없을 것 같지만 아래와 같이 가능합니다.

```js
const sum = function (a, b) {
  return a + b;
};
```

이는 자바스크립트 엔진이 코드의 문맥에 따라 동일한 함수를 문이 아닌 표현식으로 해석하는 경우가 있기 때문입니다.

따라서 기명 함수 리터럴은 코드의 문맥에 따라 선언문으로도, 표현식으로도 사용될 수 있음을 알고 있어야 합니다.

###### 암묵적인 규칙

함수 표현식에서는 위와 같이 할당하려는 함수의 이름을 생략하는 것이 일반적입니다.
이는 코드를 읽는데 혼란을 방지하기 위함입니다.

```js
const sum = function add(a, b) {
  return a + b;
};

sum(10, 14); // 24
add(10, 14); // Uncaught ReferenceError: add is not defined
```

실제로 함수를 호출하기 위해 사용된 것은 sum 입니다.
add는 함수 내부에서만 유효한 식별자일 뿐, 함수를 외부에 호출하는 데에는 사용할 수 없습니다.

따라서 함수 표현식에서 함수에 이름을 주는 것은 함수 호출에 도움이 되지 않을 뿐만 아니라 코드를 읽는데 방해가 되는 요소가 될 수 있습니다.

<br />

#### ③ function 생성자

Function 생성자 함수는 모두 문자열로 작성해야 합니다. <br />
이는 메모장에 코드를 작성하는 것만큼 어려운 방법이며 코드의 양이 길어질수록 혼란은 가중되게 됩니다.

```js
const add = new Function("a", "b", "return a + b");

add(10, 14); //24
```

또한 생성자 방식으로 함수를 선언할 경우 함수의 클로저가 생성되지 않습니다.

따라서 생성자 함수 방식으로 함수를 만드는 것은 권장되지 않고 있으며 실제 코딩에서도 사용되지 않는 방법이라 봐도 무방합니다.

<br />

#### ④ 화살표 함수

ES6에 새롭게 추가된 함수 생성 방식입니다. <br />

```js
const add = (a, b) => {
  return a + b;
};
```

```js
// 위와 같이 코드가 한 줄일 때에는 블록 생략 가능
const add = (a, b) => a + b;

// 매개변수의 개수가 1개일 때에는 중괄호 생략 가능
const hello = (name) => console.log(`hello, ${name}`);
```

<br />
<br />

### 함수 선언 식과 표현식의 차이

두 가지 방식의 가장 큰 차이는 호이스팅 여부 입니다.

<br />

> 📖 호이스팅 <br />
> 자바스크립트 엔진에 의해 선언된 변수와 함수가 해당 스코프의 최상단으로 끌어올려지는 현상

> 함수의 호이스팅 <br />
> 함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트의 특징 <br />
> 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업을 의미

> 변수의 호이스팅 <br />
> 함수 호이스팅과는 다르게 호이스티되는 시점에서 var의 경우 undefined로 초기화 <br />

<br />

```js
// 함수 선언문은 호이스팅 O

hello(); // "hello"

function hello() {
  console.log("hello");
}

hello(); // "hello"
```

```js
// 함수 표현식은 호이스팅 X

console.log(typeof hello === "undefined"); // true
hello(); // Uncaught TypeError : hello is not a function

var hello = function () {
  console.log("hello");
};

hello(); // "hello"
```

<br />
<br />

### 일반 함수와 화살표 함수의 차이

##### ① this 바인딩

this 바인딩의 차이로 인해 클래스 컴포넌트에서 이벤트 바인딩을 어떤 함수로 메서드를 선언했는지에 따라 다르게 동작합니다.

> 📖 this란 <br />
> 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값 <br />
> 함수가 어떻게 호출되느냐에 따라 동적으로 결정

<br />

일반 함수는 자신 만의 this를 갖는 반면, 화살표 함수는 함수 자체의 바인딩을 갖지 않습니다.
따라서 화살표 함수는 상위 스코프의 this를 그대로 따르게 됩니다.

<br />

##### ② arguments 존재 여부

화살표 함수는 arguments가 존재하지 않기 때문에 암묵적으로 arguments 객체를 사용하려고 할 경우 참조 에러가 발생합니다.

화살표 함수에서 가변 인자를 사용하고 싶은 경우, rest 파라미터나 spread 연산자를 사용해야 합니다.

```js
// 일반 함수
function general() {
  console.log(arguments);
}

general(1, 2, 3); // Arguments(3)[1,2,3, callee: f. Symbol(Symbol.iterator): f]
```

```js
// 화살표 함수
const arrow = () => {
  console.log(arguments);
};

arrow(1, 2, 3); // Uncaught ReferenceError: arguments is not defined
```

<br />

##### ③ 생성자 함수 사용 여부

화살표 함수에서는 constructor 메서드를 사용할 수 없기 때문에 생성자 함수로 사용이 불가합니다.

일반 함수는 new 키워드와 함께 호출하면 내부에서 새로운 객체를 만들고, 그 객체를 초기화하기 위해 **this**가 사용됩니다. 이때 **constructor**가 실행되면서 새로운 인스턴스가 만들어집니다.

하지만 화살표 함수는 this 바인딩 방식이 다릅니다. 위에서도 설명 했지만 화살표 함수는 자신만의 **this**를 갖지 않고, 상위 스코프에서의 this를 그대로 사용합니다. 즉, 화살표 함수 내부에서는 **this**를 새로 정의하거나 new로 호출하는 상황에 맞춰 새로운 인스턴스를 만들 수 없다는 것이죠.

따라서 화살표 함수는 생성자 함수로 사용되지 못하는 것입니다.

```js
const Car = (name) => {
  this.name = name;
};

const myCar = new Car("페라리"); // Uncaught TypeError: Car is not a constructor
```

간단히 말하면, 화살표 함수는 객체를 만들고 관리하는 특수한 constructor 역할을 할 수 없기 때문에, new 키워드와 함께 사용할 수 없습니다.

<br />
<br />

## 리액트에서 자주 쓰이는 함수들

###### IIFE(Immediately Invoked Function Expression)

### 즉시 실행 함수

이름대로 함수를 정의하는 순간 즉시 실행되는 함수 <br />
단 한 번만 호출되고, 다시 호출할 수 없는 함수 <br />

재호출이 불가능하기 때문에 일반적으로 즉시 실행 함수에는 이름을 붙이지 않습니다.

```js
// 기본 형태 : ()()

// 일반 함수
(function (a, b) {
  return a + b;
})(10, 24); // 34

// 화살표 함수
((a, b) => {
  return a + b;
})(10, 14); // 34
```

이런 즉시 실행 함수의 특성을 활용하면 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프를 운용할 수 있다는 장점이 있습니다.

함수의 선언과 실행이 바로 그 자리에서 끝나기 때문에 즉시 실행 함수 내부에 있는 값은 외부에서 접근이 불가능하기 때문입니다.

또한 이 함수는 어디서든 다시 호출도지 않는다는 점을 각인시킬 수 있어 리팩터링에도 매우 도움이 됩니다.

따라서 재사용되지 않는 함수이며 한 번의 실행으로 끝난다면 즉시 실행 함수의 사용을 고려해보는 것이 좋습니다.

<br />
<br />

###### Higher Order Function

### 고차 함수

함수가 일급 객체임을 활용해 함수를 인수로 받거나 결과로 새로운 함수를 반환시키게 할 수 있는데 이러한 함수를 고차 함수라고 합니다.

```js
// 함수를 매개변수로 받는 대표적인 고차 함수, Array.prototype.map
const doubledArray = [1, 2, 3].map((item) => item * 2);

doubledArray; // [2,4,6]
```

```js
// 함수를 반환하는 고차 함수의 예시
const add = function (a) {
  // a가 존재하는 클로저를 생성
  return function (b) {
    // b를 인수로 받아 . 두합을 반환하는 또 다른 함수를 생성
    return a + b;
  };
};

add(1)(2); // 3
```

<br />

#### 고차 컴포넌트

함수 컴포넌트를 인수로 받아 새로운 함수 컴포넌트를 반환하는 고차 함수를 만들 수도 있으며 이를 고차 컴포넌트(Higher Order Component) 라고 합니다.

고차 함수 컴포넌트를 만들면 컴포넌트 내부에서 공통으로 관리되는 로직을 분리해 관리할 수 있어 효율적인 리팩터링이 가능합니다.

<br />
<br />

## 함수 생성 시 주의 사항

#### ① 함수의 부수효과를 최소화할 것

> 함수의 부수 효과(side-effect)란 <br />
> 함수 내의 작동으로 인해 함수 외부에 영향을 끼치는 것

부수 효과가 없는 함수를 순수 함수, 있는 함수를 비순수 함수라고 합니다.

즉, 순수 함수는 어떤 상황에서든 동일한 인수를 받으면 동일한 결과를 반환해야 하며 작동 중 외부에 어떠한 영향도 미쳐서는 안 됩니다.<br />
따라서 순수 함수는 예측 가능하며 안정적이라는 장점이 있습니다.

하지만 부수 효과는 피할 수 없는 요소이기도 합니다.
그럼에도 이런 부수 효과를 최대한 억제할 수 있는 방향으로 함수를 설계해야 합니다.

##### 리액트의 관점

리액트의 관점에서는 부수 효과를 처리하는 훅인 useEffect의 작동을 최소화하는 것이 그 일환이라고 볼 수 있습니다.

useEffect의 사용은 피할 수 없지만 최소한으로 사용해 함수의 역할을 좁힘으로써 버그를 줄여 결과적으로 컴포넌트의 안정성을 높일 수 있습니다.

<br />

#### ② 함수의 크기를 최대한 작게 만들 것

> "Do One Thing and Do It Well." - Malcolm Douglas McIlory <br />
> "함수는 하나의 일을, 그 하나만 잘하면 된다." - 더글러스 매킬로이

<br />

하나의 함수에서 너무나 많은 일을 하지 않게 해야 합니다. <br />
이는 함수의 원래 목적인 재사용성을 높이는 방법이기도 합니다.

##### ESLint의 `max-lines-per-function`

이 규칙의 기본값은 함수가 50줄 이상이 넘어가면 과도하게 커진 함수로 분류하고 경고 메세지를 출력합니다. <br />
그 외에도 중첩이 얼마나 됐는지, 콜백은 얼마나 많은지도 확인이 가능합니다.

함수의 크기가 어느 정도가 적당한지는 환경마다 상황마다 다르겠지만, 요지는 함수의 크기는 최소한으로 유지하는 것이 좋다는 것입니다.

<br />

#### ③ 이름만으로도 기능을 유추할 수 있게 작명할 것

클린 코드나 리팩터링 등에서도 많이 언급되는 문제지만, 가능한 한 함수 이름은 간결학 이해하기 쉽게 붙이는 것이 좋습니다.

##### Tester

<br />

> 📖 Tester <br />
> 자바스크립트 코드를 맹글링 및 압축하는 도구

> 📖 맹글링(mangling) <br />
> 코드를 컴파일러가 이해할 수 있는 수준에서 단순화하는 것

<br />

프로젝트의 프레임워크에 Tester가 설치돼 있다면 한글로 네이밍하는 것도 한 방법일 수 있습니다.

<br />
<br />
