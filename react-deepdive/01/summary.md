# 리액트 개발을 위해 꼭 알아야 할 자바스크립트

### 1. 동등 비교

리액트에서는 `Object.is`를 기반으로 동등 비교를 하는 `shallowEqual` 함수를 만들어 사용합니다.

기본적으로 리액트는 props에서 꺼내온 값을 기준으로 렌더링을 수행하기 때문에 일반적으로 얕은 비교로 충분하기 때문에 얕은 비교까지만 구현되어 있습니다.

이러한 특징은 props가 깊어질 경우 예상치 못하게 작동할 수 있음에 유의해야 하며 향후 아래 부분들을 이해하는데 도움이 됩니다.

    ① 함수 컴포넌트에서 사용되는 훅의 의존성 배열의 비교
    ② 렌더링 방지를 넘어선 useMemo와 useCallback의 필요성
    ③ 렌더링 최적화를 위해 꼭 필요한 React.memo를 올바르게 작동시키 위해 고려해야 하는 점들

<br />
<br />

### 2. 함수

리액트에서 자주 쓰이는 함수에는 즉시 실행 함수와 고차 함수가 있습니다. <br />

그리고 이런 고차 함수의 특징을 활용한 고차 컴포넌트도 있습니다. <br />
고차 함수 컴포넌트를 만들면 컴포넌트 내부에서 공통으로 관리되는 로직을 분리해 관리할 수 있어 효율적인 리팩터링이 가능합니다.

<br />

함수를 생성할 때에는 아래 세 가지에 유의해야 합니다 :

    ① 함수의 부수효과를 최소화
    ② 함수의 크기를 최소화
    ③ 함수의 이름은 직관적으로

리액트의 관점에서는 부수 효과를 처리하는 훅인 useEffect의 작동을 최소화하는 것이 함수의 부수효과를 최소화하는 일환으로 볼 수 있습니다.

useEffect의 사용은 피할 수 없지만 최소한으로 사용해 함수의 역할을 좁힘으로써 버그를 줄여 결과적으로 컴포넌트의 안정성을 높일 수 있습니다.

또한 함수의 크기는 ESLint의 `max-lines-per-function` 규칙으로도 제어할 수 있습니다.

<br />
<br />

### 3. 클래스

클래스는 특정한 객체를 만들기 위한 일종의 템플릿과 같은 개념으로 특정한 형태의 객체를 반복적으로 만들기 위해 사용되는 것이라고 볼 수 있습니다.

클래스의 동작은 생성자 함수로 매우 유사하게 재현할 수 있는 것으로 객체지향 언어에 익숙한 개발자들에게 일종의 문법적 설탕 역할을 하는 문법이라고 볼 수 있습니다.

자바스크립트 개발자라면 클래스보다는 함수가 좀 더 익숙하겠지만, <br />
과거 리액트의 많은 코드들이 클래스 컴포넌트로 생성되었을 뿐만 아니라 <br />
클래스를 이해하고 나면 아래 부분들을 이해하는데 도움이 됩니다.

- 클래스 컴포넌트에 어떻게 생명주기를 구현할 수 있는지
- 왜 클래스 컴포넌트 생성을 위해 React.Component나 React.PureComponent를 상속하는지
- 메서드가 화살표 함수와 일반 함수일 때 어떤 차이가 있는지

<br />
<br />

### 4. 클로저

클로저를 이해하기 위해서는 스코프(전역 스코프와 함수 스코프)에 대한 이해가 필요합니다. <br />

리액트에서 클로저의 개념이 활용되는 부분은 훅함수 중 useState 라고 볼 수 있습니다. <br />
useState 함수의 호출은 대부분 한 줄로 끝납니다. 그럼에도 불구하고 setState 함수는 계속 내부의 최신값(prev)을 알고 있는데 이는 클로저를 활용했기 때문입니다.

클로저는 내부 함수가 외부 함수의 선언적 환경(lexical scope)을 기억하고 있어야 하므로 비용이 발생하게 됩니다. 따라서 꼭 필요한 부분에만 클로저를 활용할 수 있도록 주의가 필요합니다.

<br />
<br />

### 5. 이벤트 루프와 비동기 통신의 이해

<p align="center">
<img width="80%" src="https://github.com/user-attachments/assets/e12333c9-d473-4ad8-b12f-87646fcff254" alt="event loop" />
</p>

자바스크립트는 싱글 스레드로 동작하기 때문에 한 번에 한 가지의 작업 밖에 처리할 수 없습니다. <br />
이러한 단점을 보완하기 위해 자바스크립트 런타임 엔진은 이벤트 루프라는 장치를 통해 비동기 작업을 수행합니다. <br />

이벤트 루프는 비동기 작업을 우선 web API라는 대기 공간에 보내 동기 작업들을 호출 스택(call stack)에서 처리합니다.

비동기 작업은 web API에서 비동기와 관련된 로직을 처리한 뒤 각각 태스크 큐와 마이크로 태스크 큐로 나눠 보내집니다.

태스크 큐와 마이크로 태스크 큐에 쌓인 작업들은 호출 스택이 비었을 때 처리되며, 마이크로 태스크 큐가 더 높은 우선순위를 갖기 때문에 마이크로 태스크 큐의 작업들이 먼저 처리되게 됩니다.

<br />
<br />

### 6. 기타

##### 1. 구조 분해 할당과 전개 구문

- 구조 분해 할당과 전개 구문은 객체의 경우 바벨로 트랜스파일을 거치면 부담이 되므로 주의 필요
- 전개 구문의 경우 위치에 따라 값이 덮어씌워질 수도, 덮어쓸 수도 있으므로 의도에 맞게 배치

##### 2. 객체 초기자

- 객체 선언 시 존재하는 변수 할당 가능
- 트랜스파일 시 비교적 가벼움

##### 3. 배열과 관련된 메서드 (map, filter, reduce, forEach)

- 기존 배열의 값을 건드리지 않고 새로운 값을 만들어 안전하게 사용 가능
- 별도의 트랜스파일이나 폴리필 과정이 불필요 (ES5부터 존재)
- forEach의 경우 반환값이 의미 없으며 (undefined), 한 번 실행 시 멈출 수 없음을 유의

##### 4. 삼항 연산자

- 중첩할 경우 가독성이 떨어지므로 단독 사용 권장

<br />
<br />

### 7. 타입스크립트

타입스크립트를 사용하면 타입 체크를 정적으로 런타임이 아닌 빌트 타임(트랜스파일)에 수행할 수
있습니다. <br />
즉, 에러를 미리 확인할 수 있기 때문에 타입스크립트를 사용하는 것이 좋습니다.

#### 타입스크립트 규칙

##### 1️⃣ any 대신 unknown으로

- any 사용 시 타입스크립트가 제공하는 정적 타이핑의 이점의 효용 X
- 불가피하게 타입을 단정할 수 없는 경우, unknown 권장

##### 2️⃣ 타입 가드 활용

아래 방법들을 활용해 타입의 범위를 제한하는 것 권장

###### instanceof 와 typeof

- instanceof 연산자는 객체가 특정 클래스나 생성자 함수의 인스턴스인지 확인하는 데 사용
- typeof 연산자는 특정 요소에 대한 자료형을 확인하는 데 사용

###### in

- 기본 형태 : `property in object`
- 어떤 객체에 키가 존재하는지 확인하는 용도로 사용

###### 제네릭 타입

> 📖 제네릭 타입 <br />
> 함수나 클래스 내부에서 단일 타입이 아닌 다양한 타입에 대응할 수 있도록 도와주는 도구

<br />

제네릭 타입을 활용하면 타입만 다른 비슷한 작업을 수행하는 컴포넌트를 단일 제네릭 컴포넌트로 선언해 사용 가능합니다. <br />
리액트에서 제네릭을 사용할 수 있는 코드 중 하나는 useState입니다.

```js
// generic으로 기본값 선언, 이걸 하지 않으면 undefined로 추론
function Component() {
  // state: string
  const [state, setState] = useState < string > "";
}
```

###### 인덱스 시그니처

단, 이때에는 덕 타이핑이라는 특징에 유의해야 합니다.

```js
// 타입을 사용한 인덱스 시그니처
type Eng = {[ key in 'hello' | 'hi']: string}

const greeting: Eng = {
  hello: "hello",
  hi: "hi",
};
```

> 📖 덕 타이핑 <br />
> 객체가 필요한 변수와 메서드만 지니고 있다면 그냥 해당 타입에 속하도록 인정해주는 것을 의미

<br />
<br />
