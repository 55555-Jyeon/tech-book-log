# 리액트 개발을 위해 꼭 알아야 할 자바스크립트

### 1. 동등 비교

리액트에서는 `Object.is`를 기반으로 동등 비교를 하는 `shallowEqual` 함수를 만들어 사용합니다.

기본적으로 리액트는 props에서 꺼내온 값을 기준으로 렌더링을 수행하기 때문에 일반적으로 얕은 비교로 충분하기 때문에 얕은 비교까지만 구현되어 있습니다.

이러한 특징은 props가 깊어질 경우 예상치 못하게 작동할 수 있음에 유의해야 하며 향후 아래 부분들을 이해하는데 도움이 됩니다.

    ① 함수 컴포넌트에서 사용되는 훅의 의존성 배열의 비교
    ② 렌더링 방지를 넘어선 useMemo와 useCallback의 필요성
    ③ 렌더링 최적화를 위해 꼭 필요한 React.memo를 올바르게 작동시키 위해 고려해야 하는 점들

<br />
<br />

### 2. 함수

리액트에서 자주 쓰이는 함수에는 즉시 실행 함수와 고차 함수가 있습니다. <br />

그리고 이런 고차 함수의 특징을 활용한 고차 컴포넌트도 있습니다. <br />
고차 함수 컴포넌트를 만들면 컴포넌트 내부에서 공통으로 관리되는 로직을 분리해 관리할 수 있어 효율적인 리팩터링이 가능합니다.

<br />

함수를 생성할 때에는 아래 세 가지에 유의해야 합니다 :

    ① 함수의 부수효과를 최소화
    ② 함수의 크기를 최소화
    ③ 함수의 이름은 직관적으로

리액트의 관점에서는 부수 효과를 처리하는 훅인 useEffect의 작동을 최소화하는 것이 함수의 부수효과를 최소화하는 일환으로 볼 수 있습니다.

useEffect의 사용은 피할 수 없지만 최소한으로 사용해 함수의 역할을 좁힘으로써 버그를 줄여 결과적으로 컴포넌트의 안정성을 높일 수 있습니다.

또한 함수의 크기는 ESLint의 `max-lines-per-function` 규칙으로도 제어할 수 있습니다.

<br />
<br />

### 3. 클래스

클래스는 특정한 객체를 만들기 위한 일종의 템플릿과 같은 개념으로 특정한 형태의 객체를 반복적으로 만들기 위해 사용되는 것이라고 볼 수 있습니다.

클래스의 동작은 생성자 함수로 매우 유사하게 재현할 수 있는 것으로 객체지향 언어에 익숙한 개발자들에게 일종의 문법적 설탕 역할을 하는 문법이라고 볼 수 있습니다.

자바스크립트 개발자라면 클래스보다는 함수가 좀 더 익숙하겠지만, <br />
과거 리액트의 많은 코드들이 클래스 컴포넌트로 생성되었을 뿐만 아니라 <br />
클래스를 이해하고 나면 아래 부분들을 이해하는데 도움이 됩니다.

- 클래스 컴포넌트에 어떻게 생명주기를 구현할 수 있는지
- 왜 클래스 컴포넌트 생성을 위해 React.Component나 React.PureComponent를 상속하는지
- 메서드가 화살표 함수와 일반 함수일 때 어떤 차이가 있는지

<br />
<br />

### 4. 클로저

클로저를 이해하기 위해서는 스코프(전역 스코프와 함수 스코프)에 대한 이해가 필요합니다. <br />

리액트에서 클로저의 개념이 활용되는 부분은 훅함수 중 useState 라고 볼 수 있습니다. <br />
useState 함수의 호출은 대부분 한 줄로 끝납니다. 그럼에도 불구하고 setState 함수는 계속 내부의 최신값(prev)을 알고 있는데 이는 클로저를 활용했기 때문입니다.

클로저는 내부 함수가 외부 함수의 선언적 환경(lexical scope)을 기억하고 있어야 하므로 비용이 발생하게 됩니다. 따라서 꼭 필요한 부분에만 클로저를 활용할 수 있도록 주의가 필요합니다.

<br />
<br />

### 이벤트 루프와 비동기 통신의 이해

<p align="center">
<img width="80%" src="https://github.com/user-attachments/assets/e12333c9-d473-4ad8-b12f-87646fcff254" alt="event loop" />
</p>

자바스크립트는 싱글 스레드로 동작하기 때문에 한 번에 한 가지의 작업 밖에 처리할 수 없습니다. <br />
이러한 단점을 보완하기 위해 자바스크립트 런타임 엔진은 이벤트 루프라는 장치를 통해 비동기 작업을 수행합니다. <br />

이벤트 루프는 비동기 작업을 우선 web API라는 대기 공간에 보내 동기 작업들을 호출 스택(call stack)에서 처리합니다.

비동기 작업은 web API에서 비동기와 관련된 로직을 처리한 뒤 각각 태스크 큐와 마이크로 태스크 큐로 나눠 보내집니다.

태스크 큐와 마이크로 태스크 큐에 쌓인 작업들은 호출 스택이 비었을 때 처리되며, 마이크로 태스크 큐가 더 높은 우선순위를 갖기 때문에 마이크로 태스크 큐의 작업들이 먼저 처리되게 됩니다.

<br />
<br />
