## 👩🏻‍💻 additional Information

###### 용어 정리

<br />
<br />

### 2. useEffect

애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 매커니즘 <br />
이 부수 효과가 '언제' 일어나는지보다 어떤 상태 값과 함께 실행되는지 살펴보는 것이 더 중요

첫 번째 인수로는 실행할 부수 효과가 포함된 함수를, <br />
두 번째 인수로는 의존성 배열을 전달

##### Q. useEffect는 의존성 배열의 변경을 어떻게 알아챌까?

한 가지 기억해야 하는 사실은 <br />
함수 컴포넌트는 매번 함수를 실행해 렌더링을 수행한다는 점

함수 컴포넌트는 useState의 원리에 따라 작동합니다.<br />
즉, 함수 컴포넌트는 렌더링 시마다 고유의 state와 props 값을 갖고 있습니다.

useEffect는 자바스크립트의 proxy나 데이터 바인딩, 옵저버 같은 특별한 기능을 통해 값의 변화를 관찰하는 것이 아닌 렌더링할 때마다 의존성 배열 안의 값을 보며 이전과 다른 게 하나라도 있다면 부수 효과를 실행시키는 평범한 함수입니다.

따라서 useEffect는 state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수라고 볼 수 있습니다.

<br />

#### 클린업 함수의 목적

클린업 함수라 불리는 useEffect 내에서 반환되는 함수는 정확히 무어시옥 어떤 일을 할까요? <br />
일반적으로 클린업 함수는 이벤트를 등록하고 지울 때 사용해야 한다고 알려져 있습니다.

```js
//example

export default function App() {
  const [counter, setCounter] = useState(0);

  function handleClick() {
    setCounter((prev) => prev + 1);
  }

  useEffect(() => {
    function addMouseEvent() {
      console.log(counter);
    }
    window.addEventListener("click", addMouseEvent);

    // 클린업 함수
    return () => {
      console.log("클린업 함수 실행!", counter);
      window.removeEventListener("click", addMouseEvent);
    };
  }, [counter]);
}
```

```js
// results

클린업 함수 실행! 0
1

클린업 함수 실행! 1
2

클린업 함수 실행! 2
3

...
```

클린업 함수는 새로운 값을 기반으로 렌더링 뒤에 실행되지만 <br />
변경된 값을 읽는 것이 아니라 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행됩니다.

useEffect에 이벤트를 추가했을 때 클린업 함수에서 지워야 하는 이유는 <br />
useEffect는 콜백이 실행될 때마다 이전의 클린업 함수가 존재한다면 그 클린업 ㅎ마수를 실행한 뒤에 콜백 함수를 실행하기 때문입니다.

따라서 이벤트를 추가하기 전에 이전에 등록했던 이벤트 핸들러를 삭제하는 코드를 클린업 함수에 추가하는 것입니다.

이렇게 해야 특정 이벤트의 핸들러가 무한히 추가되는 것을 방지할 수 있습니다.

<br />

#### 의존성 배열

의존성 배열을 빈 채로 둔다면 해당 useEffect는 비교할 의존성이 없다고 판단해 <br />
최초 렌더링 직후에 실행된 다음부터는 더 이상 실행되지 않습니다.

아무런 값도 넘겨주지 않는다면 이때는 의존성 배열을 비굫라 필요 없이 렌더링할 때마다 실행이 필요하다고 판단해 렌더링이 발생할 때마다 실행됩니다. <br />
이런 방법은 보통 컴포넌트가 렌더링됐는지 확인하기 위한 방법으로 사용됩니다.

##### Q. 의존성 배열이 없는 useEffect가 매 렌더링마다 실행된다면, 그냥 useEffect 없이 사용할 순 없을까?

SSR 관점에서 useEffect는 클라이언트 사이드에서 실행되는 것을 보장해 줍니다. <br />
useEffect 내부에서는 window 객체의 접근에 의존하는 코드를 사용해도 됩니다.

```js
// 의존성 배열이 없는 useEffect
function Component() {
  useEffect(() => {
    console.log("rendering");
  });
}
```

위에서 useEffect는 컴포넌트 렌더링의 부수 효과(즉, 컴포넌트의 렌더링이)가 완료된 이후에 실행됩니다.

```js
// 그냥 쓰기
function Component() {
  console.log("rendering");
}
```

반면에 위와 같이 함수 내부에서의 직접 실행은 컴포넌트가 렌더링 되는 도중에 실행됩니다. <br />
따라서 SSR의 경우는 서버에서도 실행이 됩니다. <br />
그리고 이 작업은 함수 컴포넌트의 반환을 지연시키는 행위이기 때문에 무거운 작업일 경우 렌더링을 방해하는 요소로 성능에 악영향을 끼칠 수 있습니다.

<br />

useEffect의 effect는 컴포넌트의 사이드 이펙트, 즉 부수 효과를 의미합니다. <br />
useEffect는 컴포넌트가 렌더링된 후에 어떠한 부수 효과를 일으키고 싶을 때 사용하는 훅입니다.

<br />

#### useEffect의 구현

핵심은 의존성 배열의 이전 값과 현재 값의 얕은 비교입니다. <br />
리액트는 값을 비교할 때 `Object.is`를 기반으로 얕은 비교를 수행합니다. <br />
이전 의존성 배열과 현재 의존성 배열의 값에 하나라도 변경 사항이 있다면 callback으로 선언한 부수 효과를 실행ㄹ합니다.

<br />

#### 주의 사항

useEffect를 잘못 사용하면 예기치 못한 버그 발생 및 무한 루프에 빠질 수 있습니다.

<br />

1. 주석 자제

`eslint-disable-line react-hooks/exhaustive-deps` 라는 주석 사용을 자제해야 합니다. <br />
이는 ESLint의 `react-hook/exhaustive-deps` 룰에서 발생하는 경고를 무시하는 것인데, 이 룰은 useEffect 인수 내부에서 사용하는 값 중 의존성 배열에 포함돼 있지 않은 값이 있을 때 발생하는 경고를 무시하는 룰입니다.

정말로 필요할 때에는 사용할 수 있지만 대부분의 경우에는 의도치 못한 버그를 만들 간으성이 큰 코드입니다.

컴포넌트를 마운트하는 시점에만 실행시킬 의도로 빈 배열을 의존성으로 작성합니다. <br />
하지만 이 주석은 클래스 컴포넌트의 생명주기 메서드인 componentDidMount에 기반한 접근법으로 가급적이면 사용해선 안 됩니다.

<br />

useEffect는 반드시 의존성 배열로 전달한 값의 변경에 의해 실행돼야 하는 훅입니다. <br />
그러나 의존성 배열을 넘기지 ㅇ낳은 채 콜백 함수 내부에서 특정 값을 사용한다는 것은, <br />
이 부수 효과가 실제로 관찰해서 실행돼야 하는 값과는 별개로 작동한다는 의미입니다. <br />

즉, state와 props와 같은 어떤 값의 변경과 useEffect의 부수 효과가 별개로 동작한다는 것입니다.

따라서 정말로 의존성으로 빈 배열이 필요하다면 <br />
최초에 함수 컴포넌트가 마운트됐을 시점에만 콜백 함수를 실행이 필요한지를 다시 한 번 컴토해 볼 필요가 있습니다. <br />

만약 그렇다면 useEffect 내 부수 효과가 실행될 위치가 잘못됐을 가능성이 높습니다.

따라서 useEffect에 빈 배열을 넘기기 전에는 정말로 useEffect의 부수 효과가 컴포넌트의 상태와 별개로 작동해야만 하는지, 혹은 여기서 호출하는 것이 최선인지 한 번 더 검토해보는 것이 좋습니다.

<br />

2. useEffect의 첫 번째 인수에 함수명 부여하기

리액트의 공식 문서에서도 useEffect의 첫 번째 인수로 익명 함수를 넘겨줍니다. <br />
useEffect의 수가 적거나 복잡성이 낮다면 큰 문제가 되진 않습니다.
그러나 useEffect의 코드가 복잡하고 많아질수록 무슨 일을 하는 useEffect 코드인지 파악하기 어려워집니다.

이때 useEffect의 인수를 익명 함수에서 기명 함수로 바꾸는 것이 좋습니다.

<br />

3. useEffect의 크기 최소화하기

useEffect는 의존성 배열을 바탕으로 렌더링 시 의존성 배열이 변경될 때마다 부수 효과를 실행시킵니다. <br />
그리고 이 부수 효과의 크기가 커질수록 애플리케이션 성능에 악영향을 미칩니다.

만약 의존성 배열에 불가피하게 여러 변수가 들어가야 하는 상황이라면 최대한 useCallback이나 useMemo 등으로 사전에 정제한 내용들만 useEffect에 담아두는 것이 좋습니다.

<br />

4. 불필요한 외부 함수 X

useEffect의 크기를 작게 유지하는 것과 같은 맥락입니다. <br />
useEffect 내에서 사용할 부수 효과라면 내부에서 정의해 사용하는 편이 훨씬 낫습니다.

<br />

##### Q. 왜 useEffect의 인수로 비동기 함수는 안 될까?

만약 useEffect의 인수로 비동기 함수가 사용 가능하다면 <br />
비동기 함수의 응답 속도에 따라 결과가 이상하게 나올 수 있습니다.

극단적인 예로, <br />
이전 state 기반 응답이 10초가 걸렸고, 이후 바뀐 state 기반의 응답이 1초 뒤에 왔다면 이전 state 기반으로 결과가 나와버리는 불상사가 생길 수 있습니다.

이러한 문제를 useEffect의 경쟁 상태(race condition) 라고 합니다. <br />

즉, useEffect에 기술적인 문제가 있어서가 아닌, <br />
useEffect에서 비동기로 함수를 호출할 경우 경쟁 상태가 발생할 수 있기 때문입니다.

다시 말해, 이는 실행 자체가 문제가 되는 것이 아닌 인수로 비동기 함수를 지정할 수 없는 것입니다. <br />
비동기 함수가 내부에 존재하게 되면 useEffect 내부에서 비동기 함수가 생성되고 실행되는 것을 반복하기 때문에 클린업 함수에서 이전 비동기 함수에 대한 처리를 추가하는 것이 좋습니다.

정리하자면 :

1. state의 경쟁 상태를 야기할 수 있고
2. cleanup 함수의 실행 순서 보장이 되지 않기 때문에

개발자의 편의를 위해 useEffect에서 비동기 함수를 인수로 받지 않고 있습니다.

<br />
<br />
